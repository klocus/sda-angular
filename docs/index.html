<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SDA – Technologie Frontendowe</title>
</head>
<body>
<xmp theme="united" style="display:none;">
# Angular CRUD App

## Część I

### Założenia aplikacji

Projekt zakłada zbudowanie aplikacji służącej do zarządzania studentami Software Development Academy.

+ Wyświetlanie listy studentów
+ Edycja studentów
+ Dodawanie nowego studenta
+ Usuwanie studentów
+ Komunikacja poprzez API

### Wymagania wstępne

+ Podstawowa znajomość JavaScriptu oraz [TypeScriptu](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)
+ Wersja LTS [Node.js](https://nodejs.org/en/download/)
+ Menadżer pakietów [npm](https://docs.npmjs.com)
+ Edytor [Visual Studio Code](https://code.visualstudio.com)
+ [Angular CLI](https://cli.angular.io) do uruchomienia projektu
+ Konsola wiersza poleceń *(np. CMD lub PowerShell)*

### Instalacja Node.js i NPM

1. Pobierz instalator w wersji LTS z oficjalnej strony [Node.js](https://nodejs.org/en/download/).
1. Postępuj zgodnie z instrukcjami wyświetlanymi w instalatorze.
1. Uruchom ponownie komputer.

### Weryfikacja instalacji

Czas sprawdzić, czy mamy poprawnie zainstalowane Node.js i NPM. W tym celu wykonaj kilka poleceń w konsoli wiersza poleceń, aby zobaczyć, jaka
wersja każdego z nich jest zainstalowana.

1. Sprawdź wersję Node.js:
```bash
node -v
```

1. Sprawdź wersję npm:
```bash
npm -v
```

## Część II

### Instalacja Angular CLI

Angular Command Line Interface (CLI) to narzędzie, które pomaga w tworzeniu szkieletów i budowaniu Angularowych aplikacji. Przyspiesza również żmudne zadania, takie jak tworzenie plików różnego typu.

Aby zainstalować Angular CLI, w oknie konsoli wykonaj następujące polecenie:

```bash
npm install -g @angular/cli
```

### Weryfikacja instalacji

Wykonaj następujące polecenie w wierszu poleceń:

```bash
ng version
```

Polecenie powinno zwrócić aktualną wersję Angular CLI i Typescriptu.

### Stworzenie angularowej aplikacji

Skoro wszystko jest gotowe, jesteśmy gotowi do stworzenia naszej pierwszej aplikacji przy użyciu Angulara. Otwórz wiersz poleceń i wykonaj następującą komendę:
```bash
ng new my-app
```

Polecenie `ng new` wyświetli monit o podanie informacji o funkcjach, które należy uwzględnić w początkowej aplikacji. Zaakceptuj wartości domyślne poprzez `Enter`.

Komenda ta zrobi za nas kilka rzeczy:

  + Zainicjuje repozytorium `git`.
  + Utworzy plik `package.json` ze wszystkimi zależnościami Angulara.
  + Skonfiguruje TypeScript, Webpack, Testy.
  + Utworzy folder `src` z początkowym kodem.
  + Wykona `npm install`, aby pobrać wszystkie pakiety do `node_modules`.

Całkiej fajnie, co? Pamiętaj, że dobry programista, to leniwy programista. Ok, teraz przejdź do nowo stworzonego katalogu z aplikacją:

```bash
cd my-app
```
Uruchom wbudowany serwer, który obserwuje zmiany w plikach i buduje aplikację:

```bash
ng serve --open
```
Opcja `--open` automatycznie otwiera kartę w przeglądarce na http://localhost:4200/.

Jeśli instalacja i konfiguracja zakończyła się sukcesem, powinna ukazać się strona podobna do [tej](img/app-works.png).

## Część III

### src/index.html

Budujemy SPA *(ang. Single Page Application)*, więc wszystko zostanie załadowane do pliku `src/index.html`. Otwórz go i przyjrzyj się mu. Jak zapewne widzisz, to dość standardowy kod HTML, z wyjątkiem dwóch elementów specyficznych dla naszej aplikacji:

+ `<base href="/">` – znacznik potrzebny do prawidłowego działania routingu.
+ `<app-root></app-root>` – główny komponent Angulara.

### src/app
 
Katalog `app` zawiera części używane do zmontowania całej aplikacji. W tym katalogu można znaleźć moduły aplikacji, komponenty i routing.

#### app.module.ts

Będziemy często używać tego pliku. Najważniejszą częścią są metadane wewnątrz dekoratora `@NgModule`. Tam zawarte są deklaracje, importy, provider'y i bootstrap.

+ **declarations:** komponenty, dyrektywy i pipe'y.
+ **imports:** routingi i moduły.
+ **bootstrap:** lista komponentów, które chcemy załadować podczas uruchamiania aplikacji. W naszym przypadku jest to `AppComponent`.

#### app.component.ts

AppComponent wygląda trochę podobnie do modułu aplikacji, ale zamiast `@NgModule` mamy dekorator `@Component`. Ponownie najważniejszą częścią jest wartość tych atrybutów *(metadanych)*.

+ **selector:** nazwa komponentu. Pamiętasz `<app-root>` w pliku `index.html`? To właśnie tutaj jest to zdefiniowane.
+ **templateUrl:** ścieżka do pliku szablonu HTML. `<app-root>` zostanie zastąpione tym, co masz w szablonie.
+ **styleUrls:** ścieżka do pliku CSS. Arkusz styli wpłynie wyłącznie na ten komponent, czyli nie przeniknie do innych części aplikacji.

W klasie `AppComponent` można zdefiniować zmienne *(np. `title`)*, które są używane w szablonach.

Usuńmy kod znajdujący się w `app.component.html` i zastąpmy całą zawartość następującym kodem:

```html
<header class="container">
  <h1>
    {{ title }}
  </h1>
</header>

<main class="container">

</main>

<footer class="container">
  Copyright &copy; 2020 by SDA.
</footer>
```

## Część IV

### Tworzenie nowego komponentu

Utwórzmy nowy komponent do wyświetlania listy studentów. Możemy szybko go wygenerować przy pomocy Angular CLI wpisując:

```bash
ng generate component students
```

To polecenie utworzy nowy folder z czterema plikami:

```bash
CREATE src/app/students/students.component.css (0 bytes)
CREATE src/app/students/students.component.html (23 bytes)
CREATE src/app/students/students.component.spec.ts (642 bytes)
CREATE src/app/students/students.component.ts (283 bytes)
```
CLI doda również wygenerowany komponent *Students* do `AppModule`:

```bash
UPDATE src/app/app.module.ts (404 bytes)
```

Śmiało sprawdź każdy z tych plików. Będą wyglądać podobnie do wcześniej poznanych składników aplikacji. Zwróć jednak uwagę na metodę `ngOnInit()` wewnątrz pliku `students.components.ts`. Jest to jeden z kilku punktów *zaczepienia* cyklu życia. Angular wywołuję tę metodę zaraz po uruchomieniu komponentu. To dobre miejsce na wprowadzenie logiki inicjalizacji.

Dodajmy nasz nowy komponent do głównego komponentu aplikacji. Przejdź do `src/app/app.component.html` i wprowadź pomiędzy znacznik `<main>`:

```html
<app-students></app-students>
```

Jeśli masz uruchomiony proces `ng serve`, powinien on automatycznie zaktualizować stronę i wyświetlić *"students works!".*

### Szablon komponentu *Students*

Samo *"students works!"* nie jest zbyt użyteczne. Zmieńmy to poprzez dodanie kodu HTML, który będzie prezentował naszą listę studentów. Przejdź do pliku `src/app/students/students.component.html` i wklej ten kod HTML:

```html
<section>
  <table>
    <thead>
      <tr>
        <th>Imię i nazwisko</th>
        <th>Adres e-mail</th>
        <th>Akcje</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Jan Kowalski</td>
        <td><a href="mailto:jan@kowalski.pl">jan@kowalski.pl</a></td>
        <td>
          <a href="#" class="button button-green">Edycja</a>
          <button class="button button-red">Usuń</button>
        </td>
      </tr>
    </tbody>
  </table>
</section>
```

### Stylizacja aplikacji

Takie elementy jak tabele i przyciski z widoku komponentu *Students* mogą się powtarzać wielokrotnie w całej aplikacji. Z tego względu nie ma sensu stylować tych elementów wyłącznie w pliku CSS związanym z konkretnym komponentem. Zdecydowanie lepszą opcją jest użycie globalnego arukusza styli dostępnego w pliku `src/styles.css`. To właśnie w tym pliku powinny znaleźć się wszelkie uniwersalne selektory i ich właściwości, np. te dotyczące tła, fontu itd. Otwórz ten plik i wprowadź odpowiednie zmiany dla tła, tabeli oraz przycisków z wyróżnieniem na kolor czerwony i zielony (klasa *button-red* oraz *button-green*).

Przykładowa zawartość `src/styles.css`:

```css
/* Ustalenie właściwości "box-sizing" dla wszystkich elementów */
* {
  box-sizing: border-box;
}

/* Właściwości dla body */
body {
  font-family: Arial, Helvetica, sans-serif;
  font-size: 16px;
}

/* Klasa kontenera, która ma ograniczoną szerokość i wyśrodkowuje content */
/* Ustawienie lewego i prawego marginesu na "auto" wyśrodkowuje kontener */
.container {
  margin: auto 20px;
  width: 100%;
}

/* Tabele */
table {
  width: 100%;
}
table th,
table td {
  padding: 8px;
  text-align: left;
}
/* Cieniujemy co drugi (parzysty) wiersz tabeli */
/* Używamy tbody, aby upewnić się, że nie cieniujemy nagłówka - to zachowuje kolejność cieniowania */
table tbody > tr:nth-child(odd) {
  background: #dddddd;
}

/* Przyciski */
.button {
  display: inline-block;
  margin: 2px 0;
  padding: 12px 30px 14px;
  border: 0;
  background: #999999;
  border-radius: 6px;
  color: #ffffff;
  text-decoration: none;
  font-size: 16px;
  cursor: pointer;
}
/* Przycisk po najechaniu kursorem */
.button:hover {
  background: #888888;
}
/* Przycisk w stanie aktywnym */
.button:active,
.button:focus {
  background: #777777;
}

/* Przycisk w kolorze zielonym */
.button-green {
  background: #33cc55;
}
.button-green:hover {
  background: #22bb44;
}
.button-green:active,
.button-green:focus {
  background: #22aa44;
}

/* Przycisk w kolorze czerwonym */
.button-red {
  background: #dd3333;
}
.button-red:hover {
  background: #cc2222;
}
.button-red:active,
.button-red:focus {
  background: #bb2222;
}

/* Media Query dla urządzeń o minimalnej szerokości 992px */
/* czyli dla komputerów stacjonarnych */
@media (min-width: 992px) {
  .container {
    max-width: 960px;
  }
}
```

Zwróć uwagę na właściwość `box-sizing: border-box`, która jest ustawiona dla wszystkich elementów HTML. Właściwość ta sprawia, że tworzenie układów CSS jest łatwiejsze i bardziej intuicyjne, a to przez to, ponieważ zapewnia, że marginesy wewnętrzne i obramowanie nie zwiększają szerokości i wysokości elementów.

Na końcu przykładowego pliku CSS została również użyta reguła `Media Query`, która służy do wczytywania styli w zależności od rodzaju urządzenia czy dostępnej szerokości okna przeglądarki. Dzięki temu możemy dopasować stronę do wielkości urządzenia użytkownika. Więcej o tej regule znadziesz [tutaj](https://developer.mozilla.org/pl/docs/Web/CSS/Media_Queries/Using_media_queries).

## Część V

### Model pojedynczego studenta

Przed zbudowaniem CRUD-owego serwisu zdefiniujmy interfejs pojedynczego studenta do pracy z danymi. Utwórz nowy plik `student.ts` wewnątrz folderu `src/app` i dodaj do niego następujący kod:

```js
export interface Student {
  id: number;
  name: string;
  email: string;
}
```

### Utworzenie sevice'u

Zacznijmy od stworzenia serwisu zawierającego wstępną listę studentów, którymi chcemy zarządzać. Serwis przyda nam się do manipulowania danymi. Komponenty nie powinny pobierać ani zapisywać danych bezpośrednio, lecz powinny skupiać się na prezentacji danych i regulować dostęp do nich wśród różnych klas. Utwórzmy zatem serwis za pomocą interfejsu wiersza polecenia, wpisując:

```bash
ng generate service student
```

Polecenie wygeneruje szkielet klasy *StudentService* w `src/app/student.service.ts` w następujący sposób:

```js
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class StudentService {

  constructor() { }

}
```

### Funkcjonalność CRUD

Aby uruchomić funkcjonalność *Create-Read-Update-Delete*, będziemy musieli zmodyfikować trzy pliki:

+ `src/app/student.service.ts`
+ `src/app/students/students.component.ts`
+ `src/app/students/students.component.html`

#### Włączenie mechanizmu HTTP

Aby móc się komunikować ze zdalnymi serwerami przez protokół `HTTP` potrzebujemy angularowego mechanizmu o nazwie `HttpClient`. Sprawmy, by był on dostępny w każdym miejscu aplikacji w dwóch krokach. Po pierwsze, dodaj go do głównego modułu `src/app/app.module.ts` importując go na samej górze pliku:

```js
import { HttpClientModule } from '@angular/common/http';
```

Następnie, wciąż jeszcze w tym samym pliku, dodaj `HttpClient` do tablicy `imports`:

```js
imports: [
  BrowserModule,
  HttpClientModule
],
```

#### Przygotowanie service'u do CRUD-a

Zmodyfikujmy serwis `student.service.ts`, aby móc zarządzać listą studentów. Do generowania samej listy
wykorzystamy platformę [JSONPlaceholder](https://jsonplaceholder.typicode.com), która oferuje różnego rodzaju *udawane*
REST API.

Dodajmy mechanizmy `HttpClient` oraz `HttpHeaders` *(służy do konfiguracji nagłówka dla żądania HTTP)* importując je w
pliku z serwisem:

```js
import { HttpClient, HttpHeaders } from '@angular/common/http';
```

W związku z tym, iż będziemy się łączyć ze zdalnym serwerem, *StudentService* musi czekać na odpowiedź serwera, a zatem metody CRUD, które wkrótce zdefiniujemy, muszą się wykonywać asynchronicznie *(funkcje asynchroniczne nie blokują dalszego wykonywania się kodu)*. Należy zatem zaimportować klasę `Observable`, która jest kluczowym składnikiem biblioteki [RxJS](https://rxjs-dev.firebaseapp.com).

```js
import { Observable } from 'rxjs';
```

Zaimportujmy również wcześniej stworzony interfejs `Student`:

```js
import { Student } from './student';
```

Będąc nadal w *StudentService*, wstrzyknij `HttpClient` do konstruktora w prywatnej właściwości o nazwie `http`:

```js
constructor(private http: HttpClient) { }
```

Zdefiniujmy teraz *(przed konstruktorem)* prywatną zmienną `studentsUrl` z adresem do zasobu użytkowników:

```js
private studentsUrl = 'https://jsonplaceholder.typicode.com/users';
```

#### READ: Odczytanie danych studentów

Aby odczytać dane z API, musimy użyć metody `http.get()` pochodzącej z klasy `HttpClient` wewnątrz stworzonego przez nas serwisu. Metoda ta zwróci nam obiekt w postaci `Observable<Student[]>`, który wypisze tablicę studentów pozyskanych podczas żądania HTTP.

```js
getStudents(): Observable<Student[]> {
  return this.http.get<Student[]>(this.studentsUrl);
}
```

Interfejs API danych z serwera określa kształt danych JSON, które otrzyma nasza aplikacja. Natomiast nasz interfejs API danych zwraca dane studentów jako
tablicę.

Może się też tak zdarzyć, że nie będziemy chcieli pobierać listy wszystkich studentów, a jedynie konkretnego studenta o danym numerze ID. Dodajmy zatem kolejną metodę, która to umożliwi:

```js
getStudent(id: number): Observable<Student> {
  const url = `${this.studentsUrl}/${id}`;
  return this.http.get<Student>(url);
}
```

Zwróć uwagę na trzy istotne różnice w stosunku do metody `getStudents()`:

+ `getStudent()` tworzy adres URL żądania z identyfikatorem żądanego studenta.
+ Serwer powinien odpowiedzieć jednym studentem, a nie szeregiem studentów.
+ `getStudent()` zwraca `Observable <Hero>` *(obserwowalny obiekt "Student")* zamiast obserwowalnej tablicy studentów.

#### UPDATE: Aktualizacja danych studenta

Ogólna struktura metody `updateStudent()` jest podobna do struktury `getHeroes()`, ale używa ona `http.put()` do utrwalenia zmian danego studenta na serwerze. Jako, że w tym projekcie korzystamy z *udawanego* REST API, to zmiany te nie zostaną zapisane. 

Najpierw dodajmy pod zmienną `studentsUrl` nowy obiekt, tj. `httpOptions`. Interfejs API sieci web czekuje specjalnego nagłówka w żądaniach aktualizacji danych.

```js
httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};
```

Teraz możemy przystąpić do utworzenia nowej metody:
<!---->
<!-- Dlaczego ANY? -->
<!---->
```js
updateStudent(student: Student): Observable<any> {
  return this.http.put(this.studentsUrl, student, this.httpOptions);
}
```

Metoda `HttpClient.put()` przyjmuje trzy parametry:

+ Adres URL
+ dane do aktualizacji (w tym przypadku edytowany student)
+ Opcje wysyłanego żądania

#### CREATE: Tworzenie nowego studenta

Tak jak w przypadku aktualizacji, nie utworzymy na serwerze *JSONPlaceholder* nowego użytkownika, ale zasymulujemy to zdarzenie.

```js
addStudent(student: Student): Observable<Student> {
  return this.http.post<Student>(this.studentsUrl, student, this.httpOptions);
}
```

Metoda `addStudent()` różni się od `updateStudent()` na dwa sposoby:

+ Wywołuje `HttpClient.post()` zamiast `put()`.
+ Oczekuje, że serwer wygeneruje `id` dla nowego studenta, którego zwróci jako `Observable<Student>`.

#### DELETE: Usuwanie studenta

```js
deleteStudent(student: Student): Observable<Student> {
  const url = `${this.studentsUrl}/${student.id}`;
  return this.http.delete<Student>(url, this.httpOptions);
}
```

Zwróć uwagę na następujące rzeczy:

+ Metoda wywołuje `HttpClient.delete()`.
+ Adres URL to adres URL z identyfikatorem studenta do usunięcia.
+ Nie są wysyłane żadne dane, tak jak w przypadku `put()` i `post()`.

## Część VI
</xmp>
<script src="strapdown/strapdown.js"></script>
</body>
</html>